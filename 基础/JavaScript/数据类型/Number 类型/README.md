<!--
 * @Description: Number 类型
 * @Author: shenxh
 * @Date: 2021-12-21 15:39:29
 * @LastEditors: shenxh
 * @LastEditTime: 2021-12-27 16:17:18
-->

- [Number (数字) 类型](#number-数字-类型)
  - [浮点数](#浮点数)
  - [值的范围](#值的范围)
  - [NaN](#nan)
  - [数值转换](#数值转换)
    - [`Number()` 函数](#number-函数)
    - [`parseInt()` 函数](#parseint-函数)
    - [`parseFloat()` 函数](#parsefloat-函数)

# Number (数字) 类型
最基本的数值字面量格式是十进制整数，直接写出来即可：

```
let intNum = 55; // 整数
```

## 浮点数
要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不
是必须有整数，但推荐加上。下面是几个例子：

```
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以
10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大
写或小写的字母 e，再加上一个要乘的 10 的多少次幂。比如：

```
let floatNum = 3.125e7; // 等于 31250000
```

在这个例子中，floatNum 等于 31 250 000，只不过科学记数法显得更简洁。这种表示法实际上相
当于说：“以 3.125 作为系数，乘以 10 的 7 次幂。”

科学记数法也可以用于表示非常小的数值，例如 0.000 000 000 000 000 03。这个数值用科学记数法
可以表示为 3e-17。默认情况下，JavaScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如，0.000 000 3 会被转换为 3e-7）。

浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不
是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下
面的例子：

```
console.log(0.1+0.2); // 0.30000000000000004
```

> 注: 之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。

## 值的范围
由于内存的限制，JavaScript 并不支持表示这个世界上的所有数值。JavaScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 `Infinity`（无穷）值。任何无法表示的负数以 `-Infinity`（负无穷大）表示，任何无法表示的正数以 `Infinity`（正无穷大）表示。

## NaN
有一个特殊的数值叫 `NaN`，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作
失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行：

```
console.log(0/0); // NaN
```

NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10），在连续多步计算时这可能是个问题。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：

```
console.log(NaN == NaN); // false
```

为此，JavaScript 提供了 `isNaN()` 函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 `isNaN()` 后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回 true。举例如下：

```
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值 10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值 1
```

## 数值转换
有 3 个函数可以将非数值转换为数值：`Number()`、`parseInt()` 和 `parseFloat()`。`Number()` 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同。

### `Number()` 函数
`Number()` 函数基于如下规则执行转换：
+ 布尔值，`true` 转换为 1，`false` 转换为 0
+ 数值，直接返回
+ `null`，返回 0
+ `undefined`，返回 NaN
+ 字符串，应用以下规则：
  + 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number("1") 返回 1，Number("123")返回 123，Number("011")返回 11（忽略前面的零）。
  + 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值（同样，忽略前面的零）
  + 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值
  + 如果是空字符串（不包含字符），则返回 0
  + 如果字符串包含除上述情况之外的其他字符，则返回 NaN
+ 对象，调用 `valueOf()` 方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 `toString()` 方法，再按照转换字符串的规则转换

从不同数据类型到数值的转换有时候会比较复杂，看一看 `Number()` 的转换规则就知道了。下面是几个具体的例子：

```
let num1 = Number("Hello world!"); // NaN
let num2 = Number(""); // 0
let num3 = Number("000011"); // 11
let num4 = Number(true); // 1 
```

可以看到，字符串"Hello world"转换之后是 NaN，因为它找不到对应的数值。空字符串转换后是 0。字符串 000011 转换后是 11，因为前面的零被忽略了。最后，true 转换为 1。

### `parseInt()` 函数
`parseInt()` 函数解析一个参数（必要时先转换为字符串）并返回一个**整数**

```
let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt(""); // NaN
let num4 = parseInt(22.5); // 22
let num5 = parseInt("70"); // 70
```

### `parseFloat()` 函数
`parseFloat()` 函数解析一个参数（必要时先转换为字符串）并返回一个**浮点数**

```
let num1 = parseFloat("1234blue"); // 1234，按整数解析
let num3 = parseFloat("22.5"); // 22.5
let num4 = parseFloat("22.34.5"); // 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); // 31250000
```
